      subroutine INCqqbar(aintegrand,mode,q1t,q2t,phiq1t,phiq2t,
     +     y1,y2,ptdiff,phiptdiff,amx,amy,wgt)
      implicit none
c     =================================================================
c     Vegas subroutine:
c
c     different distributions
c
c     for the reaction
c     in p p --> l- l+ reaction
c     in the k_t-factorization approach
c     =================================================================

      integer mode
      double precision sqs

      double precision s,s12,am_l,am_l2,am_p,cut2_min,cut2_max,pdif
      double precision dely_min,dely_max,pi,alpha_em,units,phis
      double precision ak10,ak1x,ak1y,ak1z,dely,y1,y2,pt1,pt2,qt
      double precision alpha1,alpha2,amt1,amt2,ak20,ak2x,ak2y,ak2z
      double precision sig_ptpt,phi1,phi2,phid,phiqt
      double precision beta1,beta2,x1,x2,xi_x1,xi_x2,qtx,qty,ww
      double precision z1p,z1m,z2p,z2m,qcaptx,qcapty,q1tx,q1ty
      double precision q2tx,q2ty,q10,q1x,q1y,q1z,q20,q2x,q2y,q2z
      double precision pt1x,pt1y,pt1z,pt2x,pt2y,pt2z,pcaptx,pcapty
      double precision p10,p1x,p1y,p1z,p20,p2x,p2y,p2z,p12,p22
      double precision akapt12,akapt22,q1t2,q2t2,q1t,q2t,q12,q22
      double precision ptsum,eta1,eta2,shat,aM342,that1,that2
      double precision stild
      double precision uhat1,uhat2,aMll,dMll,aMll_min,aMll_max
      double precision ptsum_min,ptsum_max,dptsum,uhat,that
      double precision term1,term2,term3,term4,term5,term6,term7
      double precision term8,term9,term10,auxil_gamgam,g_em,amat2
      double precision ak1_x,ak1_y,ak1_z,ak2_x,ak2_y,ak2_z,amx,amy
      double precision eps12,eps22,phi10,phi11_x,phi11_y,phi102,phi112
      double precision xcostheta1,xsintheta1,xcostheta2,xsintheta2
      double precision p1mod,p1_x,p1_y,p1_z,p2mod,p2_x,p2_y,p2_z
      double precision phi20,phi21_x,phi21_y,phi202,phi212
      double precision aux2_1,aux2_2,amat2_1,amat2_2,f1,f2,f_ela,f_ine
      double precision f_ine_old,delta_x1
      double precision Phi11_dot_e,Phi11_cross_e
      double precision Phi21_dot_e,Phi21_cross_e
      double precision ff_int_xixxikt,aintegral,aintegrand
      integer icontri,imode,ilepton,imethod,imat1,imat2,idif
      integer ishat,icut2,idely,iMll,nMll,iptsum,nptsum

      double precision pt1_min, pt1_max, dpt1 
      double precision pt2_min, pt2_max, dpt2
      double precision px_plus,px_minus,px_0,px_x,px_y,px_z
      double precision py_plus,py_minus,py_0,py_x,py_y,py_z
      integer iy1, iy2, ny1, ny2, nxi_x1, nxi_x2, ixi_x1, ixi_x2
      double precision xi_x1_min, xi_x1_max, dxi_x1
      double precision xi_x2_min, xi_x2_max, dxi_x2
      double precision y1_min, y1_max, dy1
      double precision y2_min, y2_max, dy2
      integer iqt, iphiqt, iphid, iMQQbar, nqt, nphiqt, nphid, nMQQbar
      double precision qt_min, qt_max, dqt 
      double precision phiqt_min, phiqt_max, dphiqt 
      double precision phid_min, phid_max, dphid
      double precision aMQQbar_min, aMQQbar_max, dMQQbar
      integer ieta1, ieta2, neta1, neta2
      double precision eta1_min, eta1_max, deta1
      double precision eta2_min, eta2_max, deta2
      integer iEq1, iEq2, nEq1, nEq2,npt1,ipt1
      double precision Eq1, Eq1_min, Eq1_max, dEq1
      double precision Eq2, Eq2_min, Eq2_max, dEq2
      integer ixf1, ixf2, nxf1, nxf2
      double precision xf1, xf1_min, xf1_max, dxf1
      double precision xf2, xf2_min, xf2_max, dxf2,pt1_base,pt2_base
      integer ietadiff, iydiff, netadiff, nydiff
      double precision etadiff, etadiff_min, etadiff_max, detadiff
      double precision ydiff, ydiff_min, ydiff_max, dydiff,wgt
      integer iq1t,iq2t,nq1t,nq2t,nq1t2,nq2t2,iq1t2,iq2t2,npt2,ipt2
      double precision xi_q1t, xi_q2t
      double precision dq1t
      double precision dq2t 
      double precision dq1t2,dq2t2,q1t2_min,q2t2_min,q1t2_max,q2t2_max
      double precision xi_q1t_min, xi_q1t_max, dxi_q1t
      double precision xi_q2t_min, xi_q2t_max, dxi_q2t
      integer ixi_q1t, ixi_q2t, nxi_q1t, nxi_q2t
      integer nlogx1,nlogx2,ilogx1,ilogx2
      double precision alogx1,alogx2
      double precision alogx1_min,alogx1_max,dlogx1
      double precision alogx2_min,alogx2_max,dlogx2
      double precision z_min, z_max, dz  
      integer nz
      double precision ptdiff, dptdiff
      double precision ptdiffx, ptdiffy
      double precision ptsumx, ptsumy
      double precision phiq1t, phiq2t
      double precision sudakov_2,ratio2
      double precision sudakov_1,ratio1,xx1,xx2
      integer iptdiff, nptdiff
      double precision phiptdiff, phiptdiff_min, phiptdiff_max,
     2                 dphiptdiff
      integer iphiptdiff,nphiptdiff
      double precision salpha1,salpha2,sbeta1,sbeta2
      double precision t1abs,t2abs

      logical linter11, linter12
      logical linter21, linter22

      logical lwind11, lwind12, lwind21, lwind22 

      complex cmat(-1:1,-1:1)        ! for gamma gamma --> l^+ l^-


      integer iterm11,iterm22,iterm12,itermtt
      integer iz1p,iz1m,iz2p,iz2m

c     =================================================================
c     common blocks (for VegasLL code)
c     =================================================================

      double precision inp1,inp2
      double precision q1t_min,q1t_max,q2t_min,q2t_max
      double precision ptdiff_min,ptdiff_max
      double precision pt_min,pt_max
      double precision y_min,y_max,q_max
      double precision amx_min,amx_max,amy_min,amy_max
      double precision ay1,ay2

      common/cuts/inp1,inp2,
     +     ptdiff_min,ptdiff_max,
     +     y_min,y_max,
     +     pt_min,pt_max,
     +     q1t_min,q1t_max,q2t_min,q2t_max,
     +     amx_min,amx_max,amy_min,amy_max

      common/kinematics/pt1x,pt1y,ay1,pt2x,pt2y,ay2,am_l,
     +     ak10,ak1x,ak1y,ak1z,ak20,ak2x,ak2y,ak2z,
     +     px_0,px_x,px_y,px_z,py_0,py_x,py_y,py_z

c     =================================================================
c     energy in CM in GeV
c     =================================================================

      ay1 = y1
      ay2 = y2
      s12 = inp1+inp2           ! FIXME take incoming particles' mass into account ?   
      s = s12*s12

c     =================================================================
c     contribution included
c         icontri = 1: elastic-elastic
c         icontri = 2: elastic-inelastic
c         icontri = 3: inelastic-elastic
c         icontri = 4: inelastic-inelastic
c     =================================================================

      icontri = mode

c     =================================================================
c     choice of F2 structure function 
c         imode = 1: Szczurek-Uleshchenko
c         imode = 2: Fiore et al.(parametrization of JLAB data)
c         imode = 3: Suri-Yennie
c         imode = 4: resonances
c     =================================================================

      imode = 1

c     =================================================================
c     choice of the quark-antiquark pair
c         ilepton = 1: electrons
c         ilepton = 2: muons
c         ilepton = 3: tauons
c     =================================================================

      ilepton = 2

      if(ilepton.eq.1) then
c      am_l = 0.0005485799d0 ! in u !
         am_l = 0.000510998928
      elseif(ilepton.eq.2) then
c      am_l = 0.1134289256d0 ! in u !
         am_l = 0.1056583715
      elseif(ilepton.eq.3) then
c     am_l = 1.77684d0 ! in u !
         am_l = 1.77682
      endif

      am_l2 = am_l*am_l
c
c     terms in the matrix element
c
      iterm11 = 1         ! LL
      iterm22 = 1         ! TT
      iterm12 = 1         ! LT
      itermtt = 1         ! TT'  

c     =================================================================
c     How matrix element is calculated
c         imethod = 0: on-shell formula
c         imethod = 1: off-shell formula
c     =================================================================
        imethod = 1
cc      imethod = 0
c     =================================================================
c     two terms in the Wolfgang's formula for 
c     off-shell gamma gamma --> l^+ l^-
c     =================================================================
      imat1 = 2
c      imat2 = 1
c     =================================================================
c     mass of the proton
c     =================================================================
      am_p = 0.93827203d0
c     =================================================================
c     way of calculating shat
c         ishat = 1: s x1 x2
c         ishat = 2: exact formula
c     =================================================================
      ishat = 2
c     =================================================================
c     EXTRA CUTS  
c
c     extra external cuts on transverse momenta of initial photons
c     kappa_1t^2 and kappa_2t^2
c     based on cut2_min, cut2_max defined below
c
c         icut2 = 0: no extra cuts
c         icut2 = 11:  .. 
c                      x.
c         icut2 = 12:  x.
c                      ..
c         icut2 = 21:  ..
c                      .x
c         icut2 = 22:  .x
c                      ..
c     =================================================================
      icut2 = 0
      cut2_min =    0.2d0 ! 10, cut on kappa_1^2 and kappa_2^2 in GeV^2
      cut2_max = 1000.0d0 ! 40, cut on kappa_1^2 and kappa_2^2 in GeV^2
c     =================================================================
c     extra cuts on the p1t(l) and p2t(l) plane
c         idif = 0: no extra cut
c         idif = 1: extra cut
c     =================================================================
      idif = 0          ! 0 is a standard
      pdif = 2.5d0   
c     =================================================================
c     the distance in rapidity between l^+ and l^-
c     =================================================================
      idely = 0         ! 0 or 1 
      dely_min = 4.0d0
      dely_max = 5.0d0
c     =================================================================
c     fundamental constants
c     =================================================================
      pi = 4.d0*datan(1.d0)
      alpha_em = 1.d0/137.035d0
c     =================================================================
c     conversion factor
c     1/GeV^2 --> nb
c     =================================================================
      units = 10.d0*(197.3271d0)**2

c     =================================================================
c     four-vectors for incident protons
c     =================================================================

      ak10 = s12/2.d0
      ak1x = 0.d0
      ak1y = 0.d0
c      ak1z = s12/2.d0
      ak1z = dsqrt(ak10**2-am_p**2)

      ak20 = s12/2.d0
      ak2x = 0.d0
      ak2y = 0.d0
c      ak2z = -s12/2.d0  
      ak2z = -dsqrt(ak20**2-am_p**2)

      stild = s/2.d0*(1+dsqrt(1.d0-(4*am_p**4)/s**2))

c     =================================================================
c     Outgoing proton final state's mass
c     =================================================================
      if((icontri.eq.1).or.(icontri.eq.2)) amx = am_p
      if((icontri.eq.1).or.(icontri.eq.3)) amy = am_p
c      print *,'amx,amy=',amx,amy

c     =================================================================
c     arbitrary angle of the sum \vec{p1t} + \vec{p2t}
c     =================================================================
c      phis = 0.0d0    ! this is completely arbitrary phase
c     =================================================================

ctest      write(*,1012) q1t,q2t,phiq1t,phiq2t

 1012 format(1x,4(e12.4,1x))  

      q1tx = q1t*cos(phiq1t)
      q1ty = q1t*sin(phiq1t)

      q2tx = q2t*cos(phiq2t)
      q2ty = q2t*sin(phiq2t)

      ptsumx = q1tx+q2tx
      ptsumy = q1ty+q2ty

      ptsum = sqrt(ptsumx**2+ptsumy**2)

      ptdiffx = ptdiff*cos(phiptdiff)
      ptdiffy = ptdiff*sin(phiptdiff)

      pt1x = 0.5*(ptsumx+ptdiffx)
      pt1y = 0.5*(ptsumy+ptdiffy)

      pt2x = 0.5*(ptsumx-ptdiffx)
      pt2y = 0.5*(ptsumy-ptdiffy)

      pt1 = sqrt(pt1x**2+pt1y**2)
      pt2 = sqrt(pt2x**2+pt2y**2)

ctest      write(*,*) pt1,pt2

      if(pt1.lt.pt_min.or.pt2.lt.pt_min) then
        aintegrand = 0.d0
        goto 100
      endif

ctest      write(*,*) pt1,pt2

c      pt1 = pt1_min + ipt1*dpt1 - dpt1/2.
      amt1 = dsqrt(pt1**2+am_l2)

c      pt2 = pt2_min + ipt2*dpt2 - dpt2/2.
      amt2 = dsqrt(pt2**2+am_l2)

c     =================================================================
      if(idif.eq.1) then
      if(abs(pt1-pt2).gt.pdif) then
      sig_ptpt = 0.0                                                                         !?????????????????
      goto 100    ! ---->
      endif
      endif
c     =================================================================

cdel      phi1 = (phis + phid) / 2.d0
cdel      phi2 = (phis - phid) / 2.d0

cdel      pt1x = pt1*dcos(phi1)
cdel      pt1y = pt1*dsin(phi1)

cdel      pt2x = pt2*dcos(phi2)
cdel      pt2y = pt2*dsin(phi2)

      pcaptx = pt1x + pt2x
      pcapty = pt1y + pt2y

      dely = dabs(y1-y2)
c     =================================================================
c     a window in rapidity distance
c     =================================================================
      if(idely.eq.1) then
      if(dely.lt.dely_min.or.dely.gt.dely_max) goto 100
      endif

c     =================================================================
c     auxiliary quantities
c     =================================================================

      alpha1 = amt1/s12*dexp( y1)
      alpha2 = amt2/s12*dexp( y2)
      beta1  = amt1/s12*dexp(-y1)
      beta2  = amt2/s12*dexp(-y2)

ctest      write(*,1011) alpha1, beta1, alpha2, beta2
 1011 format(1x,4(e12.4,1x))  


      q1t2 = q1tx**2 + q1ty**2
      q2t2 = q2tx**2 + q2ty**2

      delta_x1 = (amx**2 + q2t2)/((1.d0-x2)*s)  

c     x1 = alpha1 + alpha2 + delta_x1
      x1 = alpha1 + alpha2
      x2 = beta1  + beta2

      xi_x1 = dlog10(x1)
      xi_x2 = dlog10(x2)

c     ixi_x1 = int((xi_x1-xi_min)/dxi)+1
c     ixi_x2 = int((xi_x2-xi_min)/dxi)+1

      z1p = alpha1/x1
      z1m = alpha2/x1
      z2p = beta1/x2
      z2m = beta2/x2

c      write(*,*) y1,y2,x1, x2

ctest      write(*,*) z1p, z1m, z2p, z2m

c     -----------------------------------------------------------------
      if(x1.gt.1.0.or.x2.gt.1.0) then
c      if(x1.gt.0.1.or.x2.gt.0.1) then
        aintegrand=0.d0
        goto 100
        endif   
c     -----------------------------------------------------------------

cdel      qtx = qt*dcos(phiqt)
cdel      qty = qt*dsin(phiqt)

      qcaptx = pcaptx
      qcapty = pcapty

c     =================================================================
c     components of the transverse momenta of the ingoing photons
c     =================================================================
cdel      q1tx = q1x                 ! (qcaptx+qtx)/2.d0
cdel      q1ty = q1y                 ! (qcapty+qty)/2.d0
cdel      q2tx = q2x                 ! (qcaptx-qtx)/2.d0
cdel      q2ty = q2y                 ! (qcapty-qty)/2.d0

ctest      write(*,*) 'hello', q1tx,q1ty,q2tx,q2ty
c     =================================================================
c     four-momenta of the outgoing protons (or remnants)
c     =================================================================

      px_plus = (1.d0-x1) * inp1 * dsqrt(2.d0)
      px_minus = (amx**2 + q1tx**2 + q1ty**2)/2.d0/px_plus
      
      px_0 = (px_plus + px_minus)/dsqrt(2.d0)
      px_z = (px_plus - px_minus)/dsqrt(2.d0)
      px_x = - q1tx
      px_y = - q1ty
      
      py_minus = (1.d0-x2) * inp2 * dsqrt(2.d0)
      py_plus =  (amy**2 + q2tx**2 + q2ty**2)/2.d0/py_minus
      
      py_0 = (py_plus + py_minus)/dsqrt(2.d0)
      py_z = (py_plus - py_minus)/dsqrt(2.d0)
      py_x = - q2tx
      py_y = - q2ty
      
c      iq1t2 = int((q1t2-qit2_min)/dqit2) + 1
c      iq2t2 = int((q2t2-qit2_min)/dqit2) + 1

ctest      write(*,*) iq1t2, iq2t2

      q1t = dsqrt(q1t2)
      q2t = dsqrt(q2t2)

      xi_q1t = dlog10(q1t)                   ! new
      xi_q2t = dlog10(q2t)                   ! new

c      iq1t = int((q1t-qit_min)/dqit) + 1
c      iq2t = int((q2t-qit_min)/dqit) + 1
c     =================================================================
c     four-momenta squared of virtual photons
c     =================================================================

      ww = (1.d0+dsqrt(1.d0-4.d0*am_p**2/s)) / 2.d0
      akapt12 = q1tx**2 + q1ty**2
      akapt22 = q2tx**2 + q2ty**2

      q10 = x1*ww*s12/2.d0*(1.+akapt12/x1**2/ww**2/s)
      q1x = q1tx
      q1y = q1ty
      q1z = x1*ww*s12/2.d0*(1.d0-akapt12/x1**2/ww**2/s)

      q20 = x2*ww*s12/2.d0*(1.d0+akapt22/x2**2/ww**2/s)
      q2x = q2tx
      q2y = q2ty
      q2z =-x2*ww*s12/2.d0*(1.d0-akapt22/x2**2/ww**2/s)

        q12 = q10**2-q1tx**2-q1ty**2-q1z**2
        q22 = q20**2-q2tx**2-q2ty**2-q2z**2

ctest      write(*,*) q12,q22

c     =================================================================
c     extra cuts on transverse momenta of initial photons
c     for better understanding results
c     =================================================================

c      linter11 = q1t2.gt.0.0.and.q1t2.lt.cut2_min
c      linter12 = q1t2.gt.cut2_min.and.q1t2.lt.cut2_max

c      linter21 = q2t2.gt.0.0.and.q2t2.lt.cut2_min
c      linter22 = q2t2.gt.cut2_min.and.q2t2.lt.cut2_max

c      lwind11 = linter11.and.linter21
c      lwind12 = linter11.and.linter22
c      lwind21 = linter12.and.linter21
c      lwind22 = linter12.and.linter22

c     =================================================================
c     only if special cuts
c     =================================================================

c      if(icut2.eq.11) then
c      if(.not.lwind11) goto 100  ! ------>
c      elseif(icut2.eq.12) then
c      if(.not.lwind12) goto 100  ! ------>
c      elseif(icut2.eq.21) then
c      if(.not.lwind21) goto 100  ! ------>
c      elseif(icut2.eq.22) then
c      if(.not.lwind22) goto 100  ! ------>
c      endif

c      write(*,1005) q1t2,q2t2
c 1005 format(1x,f8.4,3x,f8.4)
c     =================================================================
c     four-momenta of the outgoing l^+ and l^-
c     =================================================================

      p10 = alpha1*ak10 + beta1*ak20
      p1x = pt1x
      p1y = pt1y
      p1z = alpha1*ak1z + beta1*ak2z

      p20 = alpha2*ak10 + beta2*ak20
      p2x = pt2x
      p2y = pt2y
      p2z = alpha2*ak1z + beta2*ak2z

      p12 = p10**2-p1x**2-p1y**2-p1z**2
      p22 = p20**2-p2x**2-p2y**2-p2z**2

ctest      write(*,*) q10+q20, p10+p20
ctest      write(*,*) q1z+q2z, p1z+p2z
ctest      write(*,*) q1x+q2x, p1x+p2x 
ctest      write(*,*) q1y+q2y, p1y+p2y

ctest      write(*,*) p10, p1z

ctest      write(*,*) p12, p22

c      ptsum = dsqrt((p1x+p2x)**2 + (p1y+p2y)**2)

ctest      write(*,*) ptsum
c     =================================================================
c     pseudorapidities of l^+ and l^-
c     =================================================================
c
      eta1 = 0.5d0*dlog((dsqrt(amt1**2*(dcosh(y1))**2 - am_l**2) +
     2       amt1*dsinh(y1))/(dsqrt(amt1**2*(dcosh(y1))**2 - am_l**2)
     3       - amt1*dsinh(y1)))

      eta2 = 0.5d0*dlog((dsqrt(amt2**2*(dcosh(y2))**2 - am_l**2) +
     2       amt2*dsinh(y2))/(dsqrt(amt2**2*(dcosh(y2))**2 - am_l**2)
     3       - amt2*dsinh(y2)))

c      test = abs(eta2 - aeta2)

c      ieta1 = int((eta1-eta1_min)/deta1) + 1
c      ieta2 = int((eta2-eta2_min)/deta2) + 1
c
c     matrix element squared
c     averaged over initial spin polarizations
c     and summed over final spin polarizations
c     (--> see Wolfgang's notes
c     =================================================================
c     four-momenta squared of virtual photons
c     =================================================================
      q12 = q10**2-q1tx**2-q1ty**2-q1z**2
      q22 = q20**2-q2tx**2-q2ty**2-q2z**2

ctest      write(*,*) q12,q22
c     =================================================================
c     Mendelstam variables
c     =================================================================
      if(ishat.eq.1) then
      shat = s*x1*x2
      elseif(ishat.eq.2) then
      shat = (q10+q20)**2-(q1tx+q2tx)**2-(q1ty+q2ty)**2-(q1z+q2z)**2
      endif
   
      aM342 = shat

      that1 = (q10-p10)**2 -(q1tx-p1x)**2 -(q1ty-p1y)**2 -(q1z-p1z)**2
      uhat1 = (q10-p20)**2 -(q1tx-p2x)**2 -(q1ty-p2y)**2 -(q1z-p2z)**2
      that2 = (q20-p20)**2 -(q2tx-p2x)**2 -(q2ty-p2y)**2 -(q2z-p2z)**2
      uhat2 = (q20-p10)**2 -(q2tx-p1x)**2 -(q2ty-p1y)**2 -(q2z-p1z)**2

      aMll = dsqrt(aM342)
c      iMll = int((aMll-aMll_min)/dMll)+1
c      iptsum = int((ptsum-ptsum_min)/dptsum)+1

ctest      write(*,*) that1,that2,uhat1,uhat2
ctest      write(*,*) that+uhat+shat-q12-q22

      that = (that1+that2)/2.d0
      uhat = (uhat1+uhat2)/2.d0
c     =================================================================
c     polar angles of l^+ and l^- 
c     =================================================================

      p1mod = dsqrt(p1_x**2+p1_y**2+p1_z**2)
      p2mod = dsqrt(p2_x**2+p2_y**2+p2_z**2)

      xcostheta1 = p1_z / p1mod
      xsintheta1 = dsqrt(p1_x**2+p1_y**2) / p1mod

      xcostheta2 = p2_z / p2mod
      xsintheta2 = dsqrt(p2_x**2+p2_y**2) / p2mod

c     =================================================================
c     matrix elements
c     =================================================================
      if(imethod.eq.0) then
c     =================================================================
c     on-shell formula for M^2
c     =================================================================
      term1 = 6.d0*am_l**8
      term2 = -3.d0*am_l**4*that**2
      term3 = -14.d0*am_l**4*that*uhat
      term4 = -3.d0*am_l**4*uhat**2
      term5 = am_l**2*that**3
      term6 = 7.d0*am_l**2*that**2*uhat
      term7 = 7.d0*am_l**2*that*uhat**2
      term8 = am_l**2*uhat**3
      term9  = -that**3*uhat
      term10 = -that*uhat**3

      auxil_gamgam = -2.d0*(  term1+term2+term3+term4+term5
     2                    +term6+term7+term8+term9+term10 )
     3             / ( (am_l2-that)**2 * (am_l2-uhat)**2 )

      g_em = dsqrt(4.d0*pi*alpha_em)

      amat2 = g_em**4*auxil_gamgam

      elseif(imethod.eq.1)then
c     =================================================================
c     Wolfgang's formulae
c     =================================================================
ctest      write(*,*) pt1x, pt1y, pt2x, pt2y

      ak1_x = z1m*pt1x-z1p*pt2x
      ak1_y = z1m*pt1y-z1p*pt2y

      ak2_x = z2m*pt1x-z2p*pt2x
      ak2_y = z2m*pt1y-z2p*pt2y

ctest      write(*,*) ak1_x, ak1_y, ak2_x, ak2_y
ctest      write(*,*) z1p,z1m,z2p,z2m

      t1abs = (q1t2+x1*(amx**2-am_p**2)+x1**2*am_p**2)/(1.d0-x1)
      t2abs = (q2t2+x2*(amy**2-am_p**2)+x2**2*am_p**2)/(1.d0-x2)

c      t1abs = (q1t2+x1**2*am_p**2)/(1.d0-x1)
c      t2abs = (q2t2+x2**2*am_p**2)/(1.d0-x2)


c      eps12 = am_l**2 + z1p*z1m*q1t2     
c      eps22 = am_l**2 + z2p*z2m*q2t2   
      eps12 = am_l**2 + z1p*z1m*t1abs
      eps22 = am_l**2 + z2p*z2m*t2abs
ctest      write(*,*) eps12, eps22

ctest      write(*,*) q1tx, q1ty, q2tx, q2ty
ctest      write(*,*) q1x, q1y, q2x, q2y

      Phi10 = 1.d0/((ak1_x+z1p*q2tx)**2+(ak1_y+z1p*q2ty)**2+eps12)
     2      - 1.d0/((ak1_x-z1m*q2tx)**2+(ak1_y-z1m*q2ty)**2+eps12)
      Phi11_x = (ak1_x+z1p*q2tx)/
     2          ((ak1_x+z1p*q2tx)**2+(ak1_y+z1p*q2ty)**2+eps12)
     3        - (ak1_x-z1m*q2tx)/
     4          ((ak1_x-z1m*q2tx)**2+(ak1_y-z1m*q2ty)**2+eps12)
      Phi11_y = (ak1_y+z1p*q2ty)/
     2          ((ak1_x+z1p*q2tx)**2+(ak1_y+z1p*q2ty)**2+eps12)
     3        - (ak1_y-z1m*q2ty)/
     4          ((ak1_x-z1m*q2tx)**2+(ak1_y-z1m*q2ty)**2+eps12)

      Phi102 = Phi10*Phi10
      Phi112 = Phi11_x**2+Phi11_y**2

      Phi20 = 1.d0/((ak2_x+z2p*q1tx)**2+(ak2_y+z2p*q1ty)**2+eps22)
     2      - 1.d0/((ak2_x-z2m*q1tx)**2+(ak2_y-z2m*q1ty)**2+eps22)

      Phi21_x = (ak2_x+z2p*q1tx)/
     2          ((ak2_x+z2p*q1tx)**2+(ak2_y+z2p*q1ty)**2+eps22)
     3        - (ak2_x-z2m*q1tx)/
     4          ((ak2_x-z2m*q1tx)**2+(ak2_y-z2m*q1ty)**2+eps22)
      Phi21_y = (ak2_y+z2p*q1ty)/
     2          ((ak2_x+z2p*q1tx)**2+(ak2_y+z2p*q1ty)**2+eps22)
     3        - (ak2_y-z2m*q1ty)/
     4          ((ak2_x-z2m*q1tx)**2+(ak2_y-z2m*q1ty)**2+eps22)

      Phi202 = Phi20*Phi20
      Phi212 = Phi21_x**2+Phi21_y**2

c      write(*,*) Phi102,Phi112,Phi202,Phi212

c      aux2_1 = iterm11*(am_l**2+4.d0*z1p*z1m*t1abs)*Phi102
c     2        + iterm22*(z1p**2+z1m**2)*Phi112
c     3  - iterm12*4.d0*z1p*z1m*(z1p-z1m)*Phi10*(q1tx*Phi11_x+q1ty*Phi11_y)
c      aux2_2 = iterm11*(am_l**2+4.d0*z2p*z2m*t2abs)*Phi202
c     2        + iterm22*(z2p**2+z2m**2)*Phi212
c     3  - iterm12*4.d0*z2p*z2m*(z2p-z2m)*Phi20*(q2tx*Phi21_x+q2ty*Phi21_y)

      Phi11_dot_e = (Phi11_x*q1tx + Phi11_y*q1ty)/dsqrt(q1t2)
      Phi11_cross_e = (Phi11_x*q1ty - Phi11_y*q1tx)/dsqrt(q1t2)

      Phi21_dot_e = (Phi21_x*q2tx +Phi21_y*q2ty)/dsqrt(q2t2)
      Phi21_cross_e = (Phi21_x*q2ty -Phi21_y*q2tx)/dsqrt(q2t2)

      aux2_1 = iterm11*(am_l**2+4.d0*z1p**2*z1m**2*t1abs)*Phi102
     1      +iterm22*( (z1p**2 + z1m**2)*(Phi11_dot_e**2 +
     2      Phi11_cross_e**2) )
     3      + itermtt*( Phi11_cross_e**2 - Phi11_dot_e**2)        
     4      - iterm12*4.d0*z1p*z1m*(z1p-z1m)*Phi10
     5      *(q1tx*Phi11_x+q1ty*Phi11_y)

      aux2_2 = iterm11*(am_l**2+4.d0*z2p**2*z2m**2*t2abs)*Phi202
     1     +iterm22*( (z2p**2 + z2m**2)*(Phi21_dot_e**2 +
     2     Phi21_cross_e**2) )
     3     + itermtt*( Phi21_cross_e**2 - Phi21_dot_e**2)       
     4     - iterm12*4.d0*z2p*z2m*(z2p-z2m)*Phi20
     5     *(q2tx*Phi21_x+q2ty*Phi21_y)


c     =================================================================
c     convention of matrix element as in our kt-factorization
c     for heavy flavours
c     =================================================================
c      amat2_1 = (4.d0*pi*alpha_em)**2 * (x1*x2*s)**2 
c     2        * aux2_1 * 2.*z1p*z1m*q1t2 / (q1t2*q2t2)
c      amat2_2 = (4.d0*pi*alpha_em)**2 * (x1*x2*s)**2 
c     2        * aux2_2 * 2.*z2p*z2m*q2t2 / (q1t2*q2t2)
      amat2_1 = (4.d0*pi*alpha_em)**2 * (x1*x2*s)**2 
     2        * aux2_1 * 2.*z1p*z1m*t1abs / (q1t2*q2t2)*t2abs/q2t2
      
c      amat2_1 = (4.d0*pi*alpha_em)**2 * (x1*x2*s)**2 
c     2        * aux2_1 * 2.*z1p*z1m*t1abs / (q1t2*q2t2)
 
      amat2_2 = (4.d0*pi*alpha_em)**2 * (x1*x2*s)**2 
     2        * aux2_2 * 2.*z2p*z2m*t2abs / (q1t2*q2t2)

c
ctest      write(*,*) amat2_1, amat2_2
c     =================================================================
c     symmetrization
c     =================================================================

      amat2 = (imat1*amat2_1 + imat2*amat2_2)/2.d0

      xx1 = alpha1 + alpha2
      xx2 = beta1  + beta2

      sudakov_2 = (amx**2 - am_p**2 + q2t2 + xx2*am_p**2)/((1.d0-xx2)*s)  
      sudakov_1 = (q1t2 + xx1*am_p**2)/((1.d0-xx1)*s)  
      ratio1 = sudakov_1 / xx1
      ratio2 = sudakov_2 / xx2

c      if(ratio1.gt.0.01) then
c        aintegrand = 0.d0
c        goto 100
c      endif

      endif

c     ============================================
c     unintegrated photon distributions
c     interpolation on double logarithmic grid
c     of inelastic distributions
c     ============================================

      if(icontri.eq.1) then
      f1 = f_ela(x1,q1t2)
      f2 = f_ela(x2,q2t2)
      elseif(icontri.eq.2) then
      f1 = f_ela(x1,q1t2)
c      f2 = ff_int_xixxikt(imode,x2,q2t2,1)
      f2 = f_ine(x2,q2t2,amy)
c      f2 = f_ine_old(x2,q2t2,amx)
      elseif(icontri.eq.3) then
      f1 = f_ine(x1,q1t2,amx)
      f2 = f_ela(x2,q2t2)
c      f1 = ff_int_xixxikt(imode,x1,q1t2,1)
c      f2 = f_ela(x2,q2t2)
      elseif(icontri.eq.4) then
      f1 = f_ine(x1,q1t2,amx)
      f2 = f_ine(x2,q2t2,amy)
c      f1 = ff_int_xixxikt(imode,x1,q1t2,1)
c      f2 = ff_int_xixxikt(imode,x2,q2t2,1)
      endif

ctest      write(*,*) x1,q1t2,f1,x2,q2t2,f2

      if(f1.lt.1.d-20) f1 = 0.0d0
      if(f2.lt.1.d-20) f2 = 0.0d0
c     =================================================================
c     factor 2.*pi below from integration over phi_sum
c     factor 1/4 below from jacobian of transformations
c     factors 1/pi and 1/pi due to integration
c     over d^2 kappa_1 d^2 kappa_2 instead d kappa_1^2 d kappa_2^2
c     =================================================================

      aintegral = (2.d0*pi)*1.d0/(16.d0*pi**2*(x1*x2*s)**2) * amat2
     2          * f1/pi * f2/pi * (1.d0/4.d0) * units
     3          * 0.5d0 * 4.0d0 / (4.d0*pi)

c     *****************************************************************
c     =================================================================
      aintegrand = aintegral*q1t*q2t*ptdiff
c     =================================================================
c     *****************************************************************

c     -----------------------------------------------------------------
  100 continue
c     -----------------------------------------------------------------  
      return
      end  

c      include 'ff_int_xixxikt.f'
c      include 'grv_lo.f'

c
c     =================================================================
c
      function f_ela(x,akt2)

      double precision f_ela,x,akt2

cold      const = 0.004d0
cold      f_ela = const*(1.d0-x)/akt2**2

      am_p = 0.93827203d0

      alpha_em = 1.d0/137.035d0
      pi = 4.d0*atan(1.d0)
c      am_p = 0.93827d0

      Q2_ela = (akt2 + x**2*am_p**2)/(1.d0-x)
      G_dip = 1.d0/(1.d0+Q2_ela/0.71d0)**2
      G_E = G_dip      
      G_M = 2.79d0*G_dip 
      ela1 = (akt2/(akt2+x**2*am_p**2))**2
      ela2 = (4.d0*am_p**2*G_E**2 + Q2_ela*G_M**2)/(4.d0*am_p**2+Q2_ela)
      ela3 = 1.d0-(Q2_ela-akt2)/Q2_ela
c        ela2 = 1.d0
c        ela3 = 1.d0 - x**2*am_p**2/Q2_ela/(1.d0-x)
c        ela3 = 1.d0
c        f_ela = alpha_em/pi*(1.d0-x+x**2/4.d0)*ela1*ela2*ela3 / akt2
      f_ela = alpha_em/pi*ela1*ela2/Q2_ela
c        f_ela = alpha_em/pi*((1.d0-x)*ela1*ela2*ela3 + x**2/2. *G_M**2)
c     >     / akt2

      return
      end
c
c     ====================================================================
c
      function f_ine(x,akt2,amx)

      double precision f_ine,x,akt2,amx

      alpha_em = 1./137.035
      pi = 4.*atan(1.)
      am_p = 0.93827203
      am_pi = 0.1349766       ! mass of pi^0
c
      aMX2 = aMX*aMX
c
c     F2 structure function
c
      Q2min = 1./(1.-x)*(x*(aMX2-am_p**2)+x**2*am_p**2)
      Q2 = akt2/(1.d0-x) + Q2min
      x_Bj = Q2 / (Q2 + aMX2 - am_p**2)
c      print *,'q2=',q2

      Q02 = 0.8d0

      amu2 = Q2 + Q02       ! scale is shifted

      call grv95lo(x_Bj,amu2,xuv,xdv,xus,xds,xss,xg)

      F2_aux = 4./9.*(xuv + 2.*xus)
     2       + 1./9.*(xdv + 2.*xds)
     3       + 1./9.*2.*xss

c      F2_aux = 4./9.*(xuv + 2.*xus)
c     2       + 1./9.*(0.d0 + 2.*xds)
c     3       + 1./9.*2.*xss

c
c     F2 corrected for low Q^2 behaviour
c
      F2_corr = Q2 / (Q2 + Q02) * F2_aux

      term1 = (1.- x/2.d0 * (aMX2 - am_p**2 + Q2)/Q2)**2
c      term1 = (1.- x * (aMX2 - am_p**2 + Q2)/Q2)
c      term1 = (1.-(Q2-akt2)/Q2)
c      term1 = (1.- Q2min/Q2)
c       term1 = 1.d0
        term2 = (akt2/(akt2 + x*(aMX2 - am_p**2) + x**2*am_p**2))**2

      f_aux = F2_corr/(aMX2 + Q2 - am_p**2) * term1 * term2

      f_ine = alpha_em/pi*(1.-x)*f_aux/akt2

c        if (Q2.gt.1.e5.or.x_Bj.gt.0.1) then
c                f_ine = 0.d0
c        endif

c        if (Q2.gt.1.e5) then
c                f_ine = 0.d0
c        endif

c        write(*,*) x_Bj,amu2,f_aux,f_ine

      return
      end
c
c     =================================================================
c
      function f_ine_old(x,akt2,amx)

      double precision f_ine_old,akt2,amx

c
c     a simple parametrization of unintegrated photon distribution
c
      const  = 0.004d0
      akt0 = 0.5d0        ! to be tested
      f_ine_old = const*(1.d0-x)/akt2 *(1.d0-dexp(-akt2/akt0))
     >   *1.d0/amx**4

      return
      end
c
c     =================================================================
c

